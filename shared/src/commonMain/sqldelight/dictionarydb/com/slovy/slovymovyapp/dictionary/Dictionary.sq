
import com.slovy.slovymovyapp.data.dictionary.DictionaryPos;
import com.slovy.slovymovyapp.data.dictionary.LearnerLevel;
import com.slovy.slovymovyapp.data.dictionary.NameType;
import com.slovy.slovymovyapp.data.dictionary.SenseFrequency;
import com.slovy.slovymovyapp.data.dictionary.TraitType;
import kotlin.uuid.Uuid;

-- Dictionary database schema
CREATE TABLE lemma (
  id BLOB AS Uuid NOT NULL PRIMARY KEY, -- UUID
  pos INTEGER AS DictionaryPos NOT NULL,
  lemma TEXT NOT NULL,
  lemma_normalized TEXT NOT NULL
);

-- Word forms belonging to a POS entry
CREATE TABLE form (
  lemma_id BLOB AS Uuid NOT NULL REFERENCES lemma(id) ON DELETE CASCADE,
  form_id BLOB AS Uuid NOT NULL,
  form TEXT NOT NULL,
  form_normalized TEXT NOT NULL,
  PRIMARY KEY (form_id)
);

-- Tags associated with a word form (normalized list of strings)
CREATE TABLE form_tag (
  form_id BLOB AS Uuid NOT NULL REFERENCES form(form_id) ON DELETE CASCADE,
  tag TEXT NOT NULL,
  PRIMARY KEY(form_id, tag)
);

-- Senses associated with a POS entry
CREATE TABLE sense (
  sense_id BLOB AS Uuid NOT NULL PRIMARY KEY,
  lemma_id BLOB AS Uuid NOT NULL REFERENCES lemma(id) ON DELETE CASCADE,
  sense_definition TEXT NOT NULL,
  learner_level INTEGER AS LearnerLevel NOT NULL,
  frequency INTEGER AS SenseFrequency NOT NULL,
  semantic_group_id TEXT NOT NULL,
  name_type INTEGER AS NameType
);

-- Examples for a sense; example_id comes from source JSON and is scoped per sense
CREATE TABLE sense_example (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  example_id INTEGER NOT NULL,
  text TEXT NOT NULL,
  PRIMARY KEY(sense_id, example_id)
);

-- Synonyms for a sense
CREATE TABLE sense_synonym (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  synonym TEXT NOT NULL,
  PRIMARY KEY(sense_id, synonym)
);

-- Antonyms for a sense
CREATE TABLE sense_antonym (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  antonym TEXT NOT NULL,
  PRIMARY KEY(sense_id, antonym)
);

-- Common phrases for a sense
CREATE TABLE sense_common_phrase (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  phrase TEXT NOT NULL,
  PRIMARY KEY(sense_id, phrase)
);

-- Traits for a sense; trait_type constrained to known enum values
CREATE TABLE sense_trait (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  trait_type INTEGER AS TraitType NOT NULL,
  comment TEXT NOT NULL,
  PRIMARY KEY(sense_id, trait_type, comment)
);


-- Indexes to speed up searches by lemma
CREATE INDEX IF NOT EXISTS idx_lemma_lemma ON lemma(lemma COLLATE NOCASE);
CREATE INDEX IF NOT EXISTS idx_lemma_lemma_normalized ON lemma(lemma_normalized COLLATE NOCASE);

-- Indexes to speed up searches by form
CREATE INDEX IF NOT EXISTS idx_form_form ON form(form COLLATE NOCASE);
CREATE INDEX IF NOT EXISTS idx_form_form_normalized ON form(form_normalized COLLATE NOCASE);

-- Queries
insertPosEntry:
INSERT INTO lemma(id, lemma, lemma_normalized, pos)
VALUES (?, ?, ?, ?);

-- Select lemma by ID (full)
selectLemmaFullById:
SELECT l.id, l.lemma, l.pos
FROM lemma l
WHERE l.id = ?;

insertForm:
INSERT INTO form(form_id, lemma_id, form, form_normalized)
VALUES (?, ?, ?, ?);

insertFormTag:
INSERT OR IGNORE INTO form_tag(form_id, tag)
VALUES (?, ?);

insertSense:
INSERT OR REPLACE INTO sense(
  sense_id, lemma_id, sense_definition, learner_level, frequency, semantic_group_id, name_type
) VALUES (?, ?, ?, ?, ?, ?, ?);

insertSenseExample:
INSERT OR REPLACE INTO sense_example(sense_id, example_id, text)
VALUES (?, ?, ?);

insertSenseSynonym:
INSERT OR IGNORE INTO sense_synonym(sense_id, synonym)
VALUES (?, ?);

insertSenseAntonym:
INSERT OR IGNORE INTO sense_antonym(sense_id, antonym)
VALUES (?, ?);

insertSenseCommonPhrase:
INSERT OR IGNORE INTO sense_common_phrase(sense_id, phrase)
VALUES (?, ?);

insertSenseTrait:
INSERT OR IGNORE INTO sense_trait(sense_id, trait_type, comment)
VALUES (?, ?, ?);

selectFormsByForm:
SELECT f.lemma_id, f.lemma_id, f.form
FROM form f
WHERE f.form = ? COLLATE NOCASE;

selectFormsByNormalized:
SELECT f.lemma_id, f.lemma_id, f.form
FROM form f
WHERE f.form_normalized = ? COLLATE NOCASE;

selectFormsByLemmaId:
SELECT f.lemma_id, f.lemma_id, f.form
FROM form f
WHERE f.lemma_id = ?;

-- Forms with IDs for tag lookups
selectFormsWithIdByLemmaId:
SELECT f.form_id, f.form
FROM form f
WHERE f.lemma_id = ?;

selectFormTagsByFormId:
SELECT ft.form_id, ft.tag
FROM form_tag ft
WHERE ft.form_id = ?;

selectLemmasByWord:
SELECT l.id, l.lemma
FROM lemma l
WHERE l.lemma = ? COLLATE NOCASE;

-- Queries returning explicit lemma_id to avoid ambiguity in generated code
selectLemmaIdAndLemmaByWord:
SELECT l.id AS lemma_id, l.lemma
FROM lemma l
WHERE l.lemma = ? COLLATE NOCASE;

selectLemmasById:
SELECT l.id, l.lemma
FROM lemma l
WHERE l.id = ?;

selectLemmaIdByLemma:
SELECT l.id
FROM lemma l
WHERE l.lemma = ? COLLATE NOCASE;

-- Senses and related data
selectSensesByLemmaId:
SELECT s.sense_id, s.lemma_id, s.sense_definition, s.learner_level, s.frequency, s.semantic_group_id, s.name_type
FROM sense s
WHERE s.lemma_id = ?;

selectSenseExamples:
SELECT se.sense_id, se.example_id, se.text
FROM sense_example se
WHERE se.sense_id = ?;

selectSenseSynonyms:
SELECT ss.sense_id, ss.synonym
FROM sense_synonym ss
WHERE ss.sense_id = ?;

selectSenseAntonyms:
SELECT sa.sense_id, sa.antonym
FROM sense_antonym sa
WHERE sa.sense_id = ?;

selectSenseCommonPhrases:
SELECT scp.sense_id, scp.phrase
FROM sense_common_phrase scp
WHERE scp.sense_id = ?;

selectSenseTraits:
SELECT st.sense_id, st.trait_type, st.comment
FROM sense_trait st
WHERE st.sense_id = ?;

selectLemmasByNormalized:
SELECT l.id, l.lemma
FROM lemma l
WHERE l.lemma_normalized = ? COLLATE NOCASE;

selectLemmaIdAndLemmaByNormalized:
SELECT l.id AS lemma_id, l.lemma
FROM lemma l
WHERE l.lemma_normalized = ? COLLATE NOCASE;

-- LIKE-based search queries with limit 20
selectLemmasLike:
SELECT l.id, l.lemma
FROM lemma l
WHERE l.lemma LIKE ? COLLATE NOCASE
LIMIT ?;

selectLemmaIdAndLemmaLike:
SELECT l.id AS lemma_id, l.lemma
FROM lemma l
WHERE l.lemma LIKE ? COLLATE NOCASE
LIMIT ?;

selectLemmasNormalizedLike:
SELECT l.id, l.lemma
FROM lemma l
WHERE l.lemma_normalized LIKE ? COLLATE NOCASE
LIMIT ?;

selectLemmaIdAndLemmaNormalizedLike:
SELECT l.id AS lemma_id, l.lemma
FROM lemma l
WHERE l.lemma_normalized LIKE ? COLLATE NOCASE
LIMIT ?;



-- Form -> Lemma JOIN queries to avoid client-side lookups
selectLemmasByFormEquals:
SELECT l.id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form = ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;

selectLemmaIdAndLemmaByFormEquals:
SELECT l.id AS lemma_id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form = ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;

selectLemmasByFormNormalizedEquals:
SELECT l.id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form_normalized = ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;

selectLemmaIdAndLemmaByFormNormalizedEquals:
SELECT l.id AS lemma_id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form_normalized = ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;

selectLemmasFromFormsLike:
SELECT l.id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form LIKE ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;

selectLemmaIdAndLemmaFromFormsLike:
SELECT l.id AS lemma_id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form LIKE ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;

selectLemmasFromFormsNormalizedLike:
SELECT l.id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form_normalized LIKE ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;

selectLemmaIdAndLemmaFromFormsNormalizedLike:
SELECT l.id AS lemma_id, l.lemma, f.form
FROM form f
JOIN lemma l ON l.id = f.lemma_id
WHERE f.form_normalized LIKE ? COLLATE NOCASE
GROUP BY l.id, l.lemma, f.form
LIMIT ?;