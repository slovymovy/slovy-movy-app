
import com.slovy.slovymovyapp.data.dictionary.DictionaryPos;
import com.slovy.slovymovyapp.data.dictionary.LearnerLevel;
import com.slovy.slovymovyapp.data.dictionary.NameType;
import com.slovy.slovymovyapp.data.dictionary.SenseFrequency;
import com.slovy.slovymovyapp.data.dictionary.TraitType;
import kotlin.uuid.Uuid;

-- Dictionary database schema
CREATE TABLE lemma (
  id BLOB AS Uuid NOT NULL PRIMARY KEY, -- UUID
  lemma TEXT NOT NULL,
  lemma_normalized TEXT NOT NULL,
  zipf_frequency REAL NOT NULL
);

-- Parts of speech for each lemma
CREATE TABLE lemma_pos (
  id BLOB AS Uuid NOT NULL PRIMARY KEY,
  lemma_id BLOB AS Uuid NOT NULL REFERENCES lemma(id) ON DELETE CASCADE,
  pos INTEGER AS DictionaryPos NOT NULL,
  UNIQUE(lemma_id, pos)
);

-- Word forms belonging to a POS entry
CREATE TABLE form (
  lemma_pos_id BLOB AS Uuid NOT NULL REFERENCES lemma_pos(id) ON DELETE CASCADE,
  form_id BLOB AS Uuid NOT NULL,
  form TEXT NOT NULL,
  form_normalized TEXT NOT NULL,
  PRIMARY KEY (form_id)
);

-- Tags associated with a word form (normalized list of strings)
CREATE TABLE form_tag (
  form_id BLOB AS Uuid NOT NULL REFERENCES form(form_id) ON DELETE CASCADE,
  tag TEXT NOT NULL,
  PRIMARY KEY(form_id, tag)
);

-- Senses associated with a POS entry
CREATE TABLE sense (
  sense_id BLOB AS Uuid NOT NULL PRIMARY KEY,
  lemma_pos_id BLOB AS Uuid NOT NULL REFERENCES lemma_pos(id) ON DELETE CASCADE,
  sense_definition TEXT NOT NULL,
  learner_level INTEGER AS LearnerLevel NOT NULL,
  frequency INTEGER AS SenseFrequency NOT NULL,
  semantic_group_id TEXT NOT NULL,
  name_type INTEGER AS NameType
);

-- Examples for a sense; example_id comes from source JSON and is scoped per sense
CREATE TABLE sense_example (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  example_id INTEGER NOT NULL,
  text TEXT NOT NULL,
  PRIMARY KEY(sense_id, example_id)
);

-- Synonyms for a sense
CREATE TABLE sense_synonym (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  synonym TEXT NOT NULL,
  PRIMARY KEY(sense_id, synonym)
);

-- Antonyms for a sense
CREATE TABLE sense_antonym (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  antonym TEXT NOT NULL,
  PRIMARY KEY(sense_id, antonym)
);

-- Common phrases for a sense
CREATE TABLE sense_common_phrase (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  phrase TEXT NOT NULL,
  PRIMARY KEY(sense_id, phrase)
);

-- Traits for a sense; trait_type constrained to known enum values
CREATE TABLE sense_trait (
  sense_id BLOB AS Uuid NOT NULL REFERENCES sense(sense_id) ON DELETE CASCADE,
  trait_type INTEGER AS TraitType NOT NULL,
  comment TEXT NOT NULL,
  PRIMARY KEY(sense_id, trait_type, comment)
);


-- Indexes to speed up searches by lemma
CREATE INDEX IF NOT EXISTS idx_lemma_lemma ON lemma(lemma COLLATE NOCASE, zipf_frequency DESC);
CREATE INDEX IF NOT EXISTS idx_lemma_lemma_normalized ON lemma(lemma_normalized COLLATE NOCASE, zipf_frequency DESC);

-- Index for POS lookups
CREATE INDEX IF NOT EXISTS idx_lemma_pos_lemma_id ON lemma_pos(lemma_id);

-- Indexes to speed up searches by form
CREATE INDEX IF NOT EXISTS idx_form_form ON form(form COLLATE NOCASE);
CREATE INDEX IF NOT EXISTS idx_form_form_normalized ON form(form_normalized COLLATE NOCASE);

-- Queries
insertLemma:
INSERT OR IGNORE INTO lemma(id, lemma, lemma_normalized, zipf_frequency)
VALUES (?, ?, ?, ?);

insertLemmaPos:
INSERT INTO lemma_pos(id, lemma_id, pos)
VALUES (?, ?, ?);

-- Select lemma_pos by ID (full)
selectLemmaPosFullById:
SELECT lp.id, l.lemma, lp.pos, l.zipf_frequency
FROM lemma_pos lp
JOIN lemma l ON l.id = lp.lemma_id
WHERE lp.id = ?;

insertForm:
INSERT INTO form(form_id, lemma_pos_id, form, form_normalized)
VALUES (?, ?, ?, ?);

insertFormTag:
INSERT OR IGNORE INTO form_tag(form_id, tag)
VALUES (?, ?);

insertSense:
INSERT OR REPLACE INTO sense(
  sense_id, lemma_pos_id, sense_definition, learner_level, frequency, semantic_group_id, name_type
) VALUES (?, ?, ?, ?, ?, ?, ?);

insertSenseExample:
INSERT OR REPLACE INTO sense_example(sense_id, example_id, text)
VALUES (?, ?, ?);

insertSenseSynonym:
INSERT OR IGNORE INTO sense_synonym(sense_id, synonym)
VALUES (?, ?);

insertSenseAntonym:
INSERT OR IGNORE INTO sense_antonym(sense_id, antonym)
VALUES (?, ?);

insertSenseCommonPhrase:
INSERT OR IGNORE INTO sense_common_phrase(sense_id, phrase)
VALUES (?, ?);

insertSenseTrait:
INSERT OR IGNORE INTO sense_trait(sense_id, trait_type, comment)
VALUES (?, ?, ?);

selectFormsByForm:
SELECT f.lemma_pos_id, f.lemma_pos_id, f.form
FROM form f
WHERE f.form = ? COLLATE NOCASE;

selectFormsByNormalized:
SELECT f.lemma_pos_id, f.lemma_pos_id, f.form
FROM form f
WHERE f.form_normalized = ? COLLATE NOCASE;

selectFormsByLemmaPosId:
SELECT f.lemma_pos_id, f.lemma_pos_id, f.form
FROM form f
WHERE f.lemma_pos_id = ?;

-- Forms with IDs for tag lookups
selectFormsWithIdByLemmaPosId:
SELECT f.form_id, f.form
FROM form f
WHERE f.lemma_pos_id = ?;

selectFormTagsByFormId:
SELECT ft.form_id, ft.tag
FROM form_tag ft
WHERE ft.form_id = ?;

selectLemmasById:
SELECT l.id, l.lemma, l.lemma_normalized, l.zipf_frequency
FROM lemma l
WHERE l.id = ? COLLATE NOCASE;


selectLemmasByWord:
SELECT l.id, l.lemma, l.zipf_frequency
FROM lemma l
WHERE l.lemma = ? COLLATE NOCASE;

-- Queries returning explicit lemma_pos_id to avoid ambiguity in generated code
selectLemmaPosIdAndLemmaByWord:
SELECT l.id AS lemma_pos_id, l.lemma, l.zipf_frequency
FROM lemma l
WHERE l.lemma = ? COLLATE NOCASE;

selectLemmaPosIdByLemmaId:
SELECT lp.id
FROM lemma l
JOIN lemma_pos lp ON lp.lemma_id = l.id
WHERE l.id = ? COLLATE NOCASE;

-- Select lemma IDs with their POS values for a list of lemma IDs
selectLemmaIdAndPosByLemmaIds:
SELECT l.id, lp.pos
FROM lemma l
JOIN lemma_pos lp ON lp.lemma_id = l.id
WHERE l.id IN ?;

-- Senses and related data
selectSensesByLemmaPosId:
SELECT s.sense_id, s.lemma_pos_id, s.sense_definition, s.learner_level, s.frequency, s.semantic_group_id, s.name_type
FROM sense s
WHERE s.lemma_pos_id = ?;

selectSenseExamples:
SELECT se.sense_id, se.example_id, se.text
FROM sense_example se
WHERE se.sense_id = ?;

selectSenseSynonyms:
SELECT ss.sense_id, ss.synonym
FROM sense_synonym ss
WHERE ss.sense_id = ?;

selectSenseAntonyms:
SELECT sa.sense_id, sa.antonym
FROM sense_antonym sa
WHERE sa.sense_id = ?;

selectSenseCommonPhrases:
SELECT scp.sense_id, scp.phrase
FROM sense_common_phrase scp
WHERE scp.sense_id = ?;

selectSenseTraits:
SELECT st.sense_id, st.trait_type, st.comment
FROM sense_trait st
WHERE st.sense_id = ?;

selectLemmasByNormalized:
SELECT l.id, l.lemma, l.zipf_frequency
FROM lemma l
WHERE l.lemma_normalized = ? COLLATE NOCASE;

selectLemmasLike:
SELECT l.id, l.lemma, l.zipf_frequency
FROM lemma l
WHERE l.lemma LIKE ? COLLATE NOCASE
ORDER BY l.zipf_frequency DESC
LIMIT ?;

selectLemmasNormalizedLike:
SELECT l.id, l.lemma, l.zipf_frequency
FROM lemma l
WHERE l.lemma_normalized LIKE ? COLLATE NOCASE
ORDER BY l.zipf_frequency DESC
LIMIT ?;

-- Form -> Lemma JOIN queries to avoid client-side lookups
selectLemmasByFormEquals:
SELECT l.id, l.lemma, l.zipf_frequency,  f.form
FROM form f
JOIN lemma_pos lp ON lp.id = f.lemma_pos_id
JOIN lemma l ON l.id = lp.lemma_id
WHERE f.form = ? COLLATE NOCASE
GROUP BY l.id, l.lemma, l.zipf_frequency, f.form
ORDER BY l.zipf_frequency DESC
LIMIT ?;

selectLemmaPosIdAndLemmaByFormEquals:
SELECT l.id AS lemma_pos_id, l.lemma, l.zipf_frequency, f.form
FROM form f
JOIN lemma_pos lp ON lp.id = f.lemma_pos_id
JOIN lemma l ON l.id = lp.lemma_id
WHERE f.form = ? COLLATE NOCASE
GROUP BY l.id, l.lemma, l.zipf_frequency, f.form
ORDER BY l.zipf_frequency DESC
LIMIT ?;

selectLemmasByFormNormalizedEquals:
SELECT l.id, l.lemma, l.zipf_frequency, f.form
FROM form f
JOIN lemma_pos lp ON lp.id = f.lemma_pos_id
JOIN lemma l ON l.id = lp.lemma_id
WHERE f.form_normalized = ? COLLATE NOCASE
GROUP BY l.id, l.lemma, l.zipf_frequency, f.form
ORDER BY l.zipf_frequency DESC
LIMIT ?;

selectLemmasFromFormsLike:
SELECT l.id, l.lemma, l.zipf_frequency, f.form
FROM form f
JOIN lemma_pos lp ON lp.id = f.lemma_pos_id
JOIN lemma l ON l.id = lp.lemma_id
WHERE f.form LIKE ? COLLATE NOCASE
GROUP BY l.id, l.lemma, l.zipf_frequency, f.form
ORDER BY l.zipf_frequency DESC
LIMIT ?;

selectLemmasFromFormsNormalizedLike:
SELECT l.id, l.lemma, l.zipf_frequency, f.form
FROM form f
JOIN lemma_pos lp ON lp.id = f.lemma_pos_id
JOIN lemma l ON l.id = lp.lemma_id
WHERE f.form_normalized LIKE ? COLLATE NOCASE
GROUP BY l.id, l.lemma, l.zipf_frequency, f.form
ORDER BY l.zipf_frequency DESC
LIMIT ?;